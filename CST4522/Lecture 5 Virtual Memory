Recap: 
CPU reg faster than main memory faster than disk storage 


Virtual Memory is an illusion to the users that there's actually more RAM than there is actually in the system. 
Paging is a way to manage the virtual memory.



When can a system use Virtual Memory?
When a system is out of actual RAM, the OS makes use of the space available on any available disks. 

What is Paging?
It is the partitioning of physical RAM into fixed sized blocks called Frames. 							PAGE SIZE IS EQUAL TO FRAME SIZE 

Contiguous is basically continuous, sequential uninterrupted manner



Hardware and COntrol Structures:
All Memory references are dynamically translated to physical addresses at runtime. (meaning any memory reference will be comverted to actual physical addresses because processes can be swapped out and back in during runtime
																																										so it won't occupy the same space during any runtime)

A process can be broken up into pieces that do not need to be located contiguously in main memory (process can reside in any of the free "frames" during run time)


Execution of a Program:
Resider set-Portion of process that is in the main memory

What happens when a process makes a reference to a page that's not in the main RAM?
Process cannot continue it's execution, as the process must be on the secondary storage. This scenario is called PAGE FAULT, OS labels this as invalid memory reference and be put into a blocked state.
The page has to be loaded onto the RAM before execution to avoid this. The page requested but missing is called Defaulter. 



Logical Address:
Logical vs Physical Address space (Process location is not fixed in RAM, so addresses GENERATED BY CPU IS ALWAYS LOGICAL ADDRESS, and this address has to be mapped to the corresponding physical address)

eg let's say CPU has generated address 346 and actual starting starting address of process in RAM is 14346. Here, 346 is the offset, and the MMU relocates the address from 14000, so it becomes 14346



Why do we need to split the process into pieces?
We can have more proecesses in the RAM (we don't need to bring all the pieces into the RAM, so the RAM can be filled more efficiently with more processes)
A process can also be larger than the actual memory available on the system, so breaking it up makes sure that the process doesn't just die while running. 


Types of Memory:
Real memory (physical memory)
Virtual Memory (usually on storage disks)


Thrashing:
CPU is spending more time bringing pages in and out instead of actually executing processes (excessive paging operations)


Principle of Locality:
Popular characterisitcs exhibited by many applications and processes. 
Means that programs and data references tend to cluster, within a process.

Two types:
Temporal Locality (Memory location that is referenced once will be referenced again multiple times in the near future)
Spacial Locality (If a memory location is referenced once, then the program is likely to reference a nearby memory location in the near future)

Programs with good locality run faster than programs with poor locality.


Support needed for Virtual Memory:
Hardware has to support paging and sementation 
OS must be able to handle the movement of pages between primary and secondary memory 




Page Table Entries:
For Virtual Address it's: Page Number + Offset (eg. 14000 + 346)
For Page Table Entry: Page in RAM or not + Modify Bit + Other control Bits + Frame Number

Figure 8.3 explaination: (this is for not page fault scenario)
CPU generates VIrtual Address (page number + offset) and it needs to check if that page is in RAM or not, gets that page table in RAM (which is not optimal, because it can be big so even that can be split)
Register (Page Table Pointer) holds base starting address of the page table in the RAM 
It useses the page number to index into the corr number in the page table
It comes to specific location and gets the fram number (because it currently resides in the main memory (MMU does this I believe)
IT then takes that Frame # and cobines it with offset and then takes that offset and accesses the corr page in main memory 

RAM is being accessed twice (once for page table, again for the actual page frame itself) so it's slow. (Every virtual memory access doubles memory access time)

So, page tables can become lengthy, so it's not ideal solution to have the entire thing in the RAM. So better to have a part of the page table in the MainMem and another part in VirMem.

To fix this doubling of memory access because of virtual memory, Translation Lookaside Buffer (TLB)
It's basically a cache for page table entries. This cache is a highspeed cache



TLB:
This is part of a chip's mem management unit (MMU)
It's also called address translation cache
Functions the same as a memory cache
Has the more recently used page table entry (if it's in the cache then it's called cache hit, if not then it's called cache miss)
Helps us avoid the need to access the RAM for page table lookup

(then she explains the flowchart, it's pretty simple to understand just look at the ppt)

Figure 8.7:
TLB is holding page table entries (can be of many processes)
First searches TLB, then goes to access Main memory for page frame (for TLB hit)
first searched TLB, then goes to Main Memory and gets page table entry, and then goes to Main Memory (for TLB miss)
If Page fault, then it goes to Virtual Memory to get the page table entry and then accesses the main memory




Paging and Fragmentation:
Divide total size of process by page size, you get 35 + something  (1086 bytes)
Therefore last frame given is gonna be half filled (size of frame is 2048)

Smaller page size is less internal frag, but more pages required for processes, meaning larger page tables, larger portions of the page table should be in Virtual Memory (figure 8.11)


Page Size:
Most OS support only one page size (4kb for windows)

Segmentation:
The segments are varying lengths (but everything is the same basically, segment table etc) to meet the requirements 


For differences in Paging and Segmentation:
https://www.geeksforgeeks.org/difference-between-paging-and-segmentation/ 



Combined Paging and Segmentation:
Called segmented paging. Every segment that's divided, will be further sub divided into pages. So you need both Segment table for segment info, and you need page tables within the segments. 
Each segment needs one table. 
So the Virutal Address becomes: Segment Number + Page Number + Offset 




Paging Policies:

Fetch Policy - to determine when a page should be brought into memory
	Two Types:
		Demaning Paging (page to memory when there is a reference, this means that the process will suffer page fault at the start)
		PrePaging (bring into RAM before needed, it's ineffective if the pages aren't required in the future)

Replacement Policy - when no available free frames in the RAM, and a page needs to be brought into the RAM
	Which page should be replaced? Least likely to be referenced in the near future. Predicted based on past behavior
	Frame Locking (lock bit, if it's on then the page in that frame cannot be replaced)
	Basice Replacement Algos:
		Optimal Policy - Predict the future, replace the page that won't be needed in the near future (using locality of reference)
									 - Not possible because the OS needs perfect knowledge of what pages needed in the future
		Least Recently
				Used (LRU) - If a page has not be used in some time, then it might not be used in the future also for some time (popular algorithm)
							FIFO - random but simple to implement, but there's a chance that the one being replaced is the one needed by the Process at that moment 

Clock Policy - additional bit called Use bit (when first brought in, bit set to 0. when used then set to 1)
	When it's time to replace, first page with use bit set to 0 is replaced. 
		


Resident Set Size: (Resident set is what pages exist in the physical memory)
		 Fixed Allocation - if 5 frames alloted, then continues to use 5 frames
									 	  - if a page fault occurs, it will replace the page from it's own resident set. (process' own resident set)





Scope of Replacement:
Fixed Resident set ilies a local replacement policy (replace a page from process' resident set
Variable allocation implies global allocation set (number of frames alloted can vary, so it can be replaced from anywhere and not from the process' own resident set)
	Easiest to implement 



Load Control:
To have a stable system, you have to have a certain number of processes in the RAM. So processes must be broken into pieces (pages or segments)











